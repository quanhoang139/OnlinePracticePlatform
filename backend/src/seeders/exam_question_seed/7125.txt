[
    {
        "title": "Câu 1: Đền bù ",
        "point": 2.5,
        "content": "Trong việc thu hồi đất của dân để phục vụ cho việc làm đường nông thôn. Ngoài việc đền bù đất thì chính quyền còn đền bù cây ăn quả trên đất. Việc đền bù cây ăn quả trên đất được thực hiện theo định mức sau: Mỗi cây ăn quả cao từ 1 mét trở xuống là %(\\mathbf{a})%, mỗi cây ăn quả cao trên 1 mét và dưới %(2,5)% mét là %(\\mathbf{b})%, từ %(2,5)% mét trở lên là %(\\mathbf{c})%. Một hộ dân có %(\\mathbf{n})% cây ăn quả trên đất thu hồi, trong đó có %(\\textbf{m})% cây dưới %(2,5)% mét, %(\\mathbf{k})% cây từ 1 mét trở xuống.<br>Bạn hãy giúp chính quyền tính xem phải đền bù cho hộ nông dân đó số tiền là bao nhiêu.<br><i>Dữ liệu</i>: Nhập từ bàn phím 6 số nguyên dương theo thứ tự %(\\mathbf{a}, \\mathbf{b}, \\mathbf{c}, \\mathbf{k}, \\mathbf{m}, \\mathbf{n}(\\mathbf{a}, \\mathbf{b})%, %(\\mathbf{c} \\leq 100,0 \\leq \\mathbf{k}, \\mathbf{m}, \\mathbf{n} \\leq 10000, \\mathbf{k}+\\mathbf{m} \\leq \\mathbf{n}))%<br><i>Kết quả</i>: Ghi ra màn hình một số nguyên duy nhất là tổng số tiền mà chính quyền phải đền bù cho hộ nông dân trên.<br><i>Ví dụ:</i>",
        "question_images": [
            "https://docdn.giainhanh.io/media/test/375985eea189c4b1355caaf199065328.png"
        ],
        "solution": "Ta có:<br>- Số cây có chiều cao từ %(1)% mét trở xuống là %(k)%<br>- Số cây có chiều cao trên %(1)% mét và không quá %(2,5)% mét là %(m)%<br>- Số cây có chiều cao lớn hơn %(1)% mét là %(n-m-k)%<br>Bài toán qui về tính giá trị của biểu thức:<br>%(a × k + b × m + c × (n-m-k))%<br>Chương trình tham khảo:<br><strong>var a, b, c, m, n, k: longint;</strong><br><strong>BEGIN</strong><br><strong>  read(a,b,c,k,m,n);</strong><br><strong>  write(a*k+b*m+c*(n-m-k));</strong><br><strong>  close(input); close(output);</strong><br><strong>END.</strong>",
        "question_type": "essay"
    },
    {
        "title": "Câu 2: Điểm mười ",
        "point": 2.5,
        "content": "Sau kì thi vào 10 của một trường THPT, Ban Giám hiệu muốn biết có bao nhiêu điểm 10 môn Toán? Bạn hãy viết một chương trình giúp Ban Giám hiệu làm điều này.<br><i>Dữ liệu</i>: Nhập vào từ bàn phím các giá trị theo thứ tự sau:<br>- Đầu tiên là số nguyên dương %(\\mathbf{n}\\left(\\mathbf{n} \\leq 10^{6}\\right))% là số lượng học sinh dự thi<br>- Tiếp theo là %(\\mathbf{n})% số thực không âm (có giá trị không vượt quá 10) lần lượt là điểm môn Toán của %(\\mathbf{n})% học sinh<br><i>Kết quả</i>: Ghi ra màn hình duy nhất một số nguyên là số lượng điểm %(10)%<br><i>Ví dụ:</i>",
        "question_images": [
            "https://docdn.giainhanh.io/media/test/965c20c0cf1c3698b73af60c1aeb6598.png"
        ],
        "solution": "Bài toán qui về đếm số lượng giá trị 10 được nhập vào. Đây là bài toán đơn giản, có thể tham khảo chương trình dưới đây:<br><strong>var kq, i, n: longint;</strong><br><strong>  x: double;</strong><br><strong>BEGIN</strong><br><strong>  read(n);</strong><br><strong>  kq:=0;</strong><br><strong>  for i:=1 to n do</strong><br><strong>  begin</strong><br><strong>    read(x);</strong><br><strong>    if x=10 then inc(kq);</strong><br><strong>  end;</strong><br><strong>  writeln(kq);</strong><br><strong>  close(input); close(output);</strong><br><strong>END.</strong>",
        "question_type": "essay"
    },
    {
        "title": "Câu 3: Xây thành ",
        "point": 2.0,
        "content": "Để đảm bảo an ninh chống lại sự tấn công của kẻ xâm lăng, Vua An Dương Vương quyết định cho xây dựng các thành luỹ quanh các điểm dân cư đông đúc. Theo lời khuyên của Rùa thần, tên của các thành luỹ phải được chọn là một xâu con các kí tự liên tiếp nhau của tên Rùa thần. Tên của Rùa thần là một xâu ký tự Q chỉ gồm các chữ cái tiếng Anh in hoa. Ví dụ, nếu Q là 'ABAB' thì tên của thành luỹ có thể là : 'A', 'B', 'AB', 'BA', 'ABA', 'BAB', 'ABAB' (Chú ý là các tên khác nhau phải là các dãy ký tự khác nhau). Nhà Vua muốn biết là có thể xây dựng được tối đa bao nhiêu thành luỹ dựa vào số tên có thể đặt.<br><i>Dữ liệu</i>: Nhập từ bàn phím một dòng chứa xâu ký tự Q, trong đó chỉ có các chữ cái tiếng Anh in hoa và có độ dài không quá %(255)%.<br><i>Kết quả</i>: In ra màn hình duy nhất một số nguyên dương là số lượng tên khác nhau.<br><i>Ví dụ:</i>",
        "question_images": [
            "https://docdn.giainhanh.io/media/test/cb99af47bb771380f0fc0f7e40552d62.png"
        ],
        "solution": "Trong trường hợp xâu ký tự ban đầu có tất cả các ký tự khác nhau từng đôi một thi tất cả các xâu con liên tiếp đều khác nhau. Có %(n)% xâu độ dài %(1, n-1)% xâu độ dài %(2, \\ldots, 1)% xâu độ dài %(n)%. Do vậy số lượng tên phù hợp trong trường hợp này là:<br>\\[1+2+\\cdots+n=\\frac{n(n+1)}{2}\\]<br>Trong trường hợp tổng quát, với mỗi độ dài %(i(i=1 \\div n))% ta liệt kê tất cả các xâu con có thể có, bỏ đi các xâu trùng nhau.<br>Tham khảo chương trình dưới đây:<br><strong>const</strong><br><strong>  tfi='bai3.inp';</strong><br><strong>  tfo='bai3.out';</strong><br><strong>var s: string;</strong><br><strong>  n: longint;</strong><br><strong>  a: array[0..300] of string;</strong><br><strong>  p: longint;</strong><br><strong>  ds: longint;</strong><br><strong>  i, m, j, k: longint;</strong><br><strong>  d: array[0..300] of longint;</strong><br><strong>BEGIN</strong><br><strong>  readln(s);</strong><br><strong>  n:=length(s);</strong><br><strong>  ds:=0;</strong><br><strong>  for i:=1 to n do</strong><br><strong>  begin</strong><br><strong>    m:=0;</strong><br><strong>    for j:=1 to n-i+1 do</strong><br><strong>    begin</strong><br><strong>      inc(m);</strong><br><strong>      a[m]:=copy(s,j,i);</strong><br><strong>    end;</strong><br><strong>    for j:=1 to m do d[j]:=0;</strong><br><strong>    for j:=1 to m do</strong><br><strong>    for k:=1 to j-1 do</strong><br><strong>    if a[k]=a[j] then</strong><br><strong>    begin</strong><br><strong>      d[j]:=1;</strong><br><strong>      break;</strong><br><strong>    end;</strong><br><strong>    for j:=1 to m do if d[j]=0 then inc(ds);</strong><br><strong>  end;</strong><br><strong>  writeln(ds);</strong><br><strong>  close(input); close(output);</strong><br><strong>END.</strong>",
        "question_type": "essay"
    },
    {
        "title": "Câu 4: Cấp số cộng ",
        "point": 1.5,
        "content": "Trong toán học, một cấp số cộng là một dãy số, trong đó kể từ số hạng thứ hai, mỗi số hạng đều là tổng của số hạng đứng ngay trước nó với một số không đổi gọi là công sai. Chẳng hạn, dãy số %( 3, 5, 7, 9, 11)% là một cấp số cộng với các phân tử liên tiếp với công sai là %(2)%.<br>Cho dãy số nguyên %(\\mathrm{a}_{1}, \\mathrm{a}_{2}, \\ldots, \\mathrm{a}_{\\mathrm{n}})%. Ta định nghĩa một dãy con là dãy nhận được từ dãy trên bằng cách bỏ đi một số phần tử (có thể bằng 0 ) và giữ nguyên thứ tự các phần tử còn lại.<br><i>Yêu cầu</i>: Cho dãy %(\\mathrm{n})% số nguyên %(\\mathrm{a}_{1}, \\mathrm{a}_{2}, \\ldots, \\mathrm{a}_{\\mathrm{n}})% và giá trị công sai %(\\mathrm{d})% cho trước. Hãy tìm dãy con dài nhất của dãy trên lập thành một cấp số cộng với công sai %(\\mathrm{d})% (các phần tủ có thể ở vị trí bất kì trong dãy). Để đơn giản ta chỉ cần tìm số lượng phần tử của dãy con này.<br><i>Dũ liệu</i>: Vào từ file văn bản BAI4.INP<br>- Dòng đầu tiên ghi số nguyên dương %(\\mathrm{n}\\left(\\mathrm{n} \\leq 10^{5}\\right))% và giá trị công sai %(\\mathrm{d}(0 \\leq \\mathrm{d} \\leq 100))%<br>- Dòng thứ hai ghi %(\\mathrm{n})% số nguyên %(\\mathrm{a}_{1}, \\mathrm{a}_{2}, \\ldots, \\mathrm{a}_{\\mathrm{n}}\\left(1 \\leq \\mathrm{a}_{\\mathrm{i}} \\leq 10^{6}\\right))%. Hai số liên tiếp ghi cách nhau ít nhất một dấu cách<br><i>Kết quả</i>: Ghi ra file văn bản BAI4.OUT một số nguyên duy nhất là kết quả tìm được.<br><i>Ví dụ</i>:<br><i>Giải thích</i>: Dãy con dài nhất của dãy %(10)% phần tử trên thành lập cấp số cộng công sai %(3)% gồm %(6)% phần tử là: %(1, 4, 7, 10, 13, 16)%<br><img alt=\"image.png\" sizes=\"100vw\" src=\"https://docdn.giainhanh.io/media/test/4b75e73b13c981053a3154c56ff1ba09.png\" srcset=\"https://docdn.giainhanh.io/media/test/540608cf6734bbb175f094aa310ab3a0.png 245w, https://docdn.giainhanh.io/media/test/8c0d9b785768927b30355945704c1c43.png 500w, https://docdn.giainhanh.io/media/test/0315cb5e1268ac42699c0e0de5047dfe.png 750w\" width=\"750\"/>",
        "question_images": [],
        "solution": "Với %(n \\leq 5000)% ta cố định phần tử ban đầu của cấp số cộng là %(a_{i}(i=1 \\div n))%. Dựa vào phần tử này ta có các số hạng của cấp số cộng lần lượt là:<br>\\[a_{i}, a_{i}+d, a_{i}+2 d, \\ldots\\]<br>Bài toán qui về tìm %(k)% lớn nhất để %(a_{i}, a_{i}+d, \\ldots, a_{i}+(k-1) d)% nằm trong dãy đã cho. Có thể thực hiện bằng một vòng lặp.<br>Với %(n \\leq 10^{5})% : chú ý rằng với mỗi phần tử %(a_{i})% ta chỉ quan tâm đến vị trí ngay sau %(i)% xuất hiện số %(a_{i}+d)%. Do đó trước tiên chúng ta lập mảng next[1], next[2], %(\\ldots)%, next[n] với next[i]=k là chỉ số %(\\mathrm{k}\\gt \\mathrm{i})% nhỏ nhất mà %(a_{k}=a_{i})%. Việc tìm này có thể thực hiện bằng cách sử dụng mảng<br>nho: array %([0 . .2000000])% of longint;<br>với nho[x] là vị trí gần nhất xuất hiện %(\\mathrm{x})% tính từ cuối (nếu chưa xuất hiện gán 0 ):<br>for i:=1 to 2000000 do nho[i]=0;<br>for i:=n downto 1 do<br>begin<br>next[i]:=nho[a[i]+d];<br>nho[a[i]]:=i;<br>end;<br>Sau khi đã có mảng next. Đặt %(f[i])% là số lượng phần tử thuộc mảng a của cấp số cộng<br>%(a[i], a[i]+d, a[i]+2d, \\ldots)%<br>Dễ thấy công thức:<br>%(f[i]=\\left\\{\\begin{array}{c}1 \\text { if next }[\\mathrm{i}]=0 \\\\ f[\\text { next }[i]]+1 \\text { if next }[\\mathrm{i}]\\gt 0\\end{array}\\right.)%<br>Đáp số của bài toán là<br>%(max(f[1], f[2], ..., f[n]))%<br>Tham khảo chương trình dưới đây:<br><strong>program bai4;</strong><br><strong>const</strong><br><strong>  tfi='bai4.inp';</strong><br><strong>  tfo='bai4.out';</strong><br><strong>  maxn=100000;</strong><br><strong>var</strong><br><strong>  a, next, f: array[0..maxn] of longint;</strong><br><strong>  nho: array[0..2000000] of longint;</strong><br><strong>  n, d: longint;</strong><br><strong>procedure main;</strong><br><strong>var i, k: longint;</strong><br><strong>begin</strong><br><strong>  assign(input,tfi); reset(input);</strong><br><strong>  assign(output,tfo); rewrite(output);</strong><br><strong>  read(n,d);</strong><br><strong>  for i:=1 to n do read(a[i]);</strong><br><strong>  for i:=0 to 2000000 do nho[i]:=0;</strong><br><strong>  next[n]:=0; nho[a[n]]:=n;</strong><br><strong>  for i:=n-1 downto 1 do</strong><br><strong>  begin</strong><br><strong>    next[i]:=nho[a[i]+d];</strong><br><strong>    nho[a[i]]:=i;</strong><br><strong>  end;</strong><br><strong>  f[n]:=1;</strong><br><strong>  for i:=n-1 downto 1 do</strong><br><strong>  begin</strong><br><strong>    k:=next[i];</strong><br><strong>    if k>0 then f[i]:=f[k]+1</strong><br><strong>    else f[i]:=1;</strong><br><strong>  end;</strong><br><strong>  k:=1;</strong><br><strong>  for i:=2 to n do if f[i]>f[k] then k:=i;</strong><br><strong>  writeln(f[k]);</strong><br><strong>  close(input); close(output);</strong><br><strong>end;</strong><br><strong>BEGIN</strong><br><strong>  main;</strong><br><strong>END.</strong>",
        "question_type": "essay"
    },
    {
        "title": "Câu 5: Tìm max ",
        "point": 1.5,
        "content": "Nam và Trang rất thích những bài toán liên quan đến con số. Trong một lần Nam đố Trang: Bạn hãy chọn cho mình hai số nguyên dương bất kỳ %(\\mathrm{n})% và %(\\mathrm{m}\\left(2 \\leq \\mathrm{n}, \\mathrm{m} \\leq 10^{9}\\right))% mình sẽ tính ra được số nguyên dương %(\\mathrm{k})% lớn nhất sao cho %(\\mathrm{n}!=1 \\times 2 \\times 3 \\times \\ldots \\times \\mathrm{n})% chia hết cho %(\\mathrm{m}^{\\mathrm{k}})%. Trang không tin và nghĩ ra các con số để thử Nam. Hãy viết chương trình giúp Trang kiểm tra xem Nam tính ké́t quả có chính xác không nhé.<br><i>Dữ liệu</i>: Nhập từ file văn bản BAI5.INP, gồm một dòng duy nhất chứa 2 số nguyên dương %(N, M)% cách nhau một dấu cách.<br><i>Kết quả</i>: In ra file văn bản BAI5.OUT số nguyên %(K)% tìm được.<br><i>Ví dụ:</i>",
        "question_images": [
            "https://docdn.giainhanh.io/media/test/7e6701d1a1ead00e75407b56f2dd93f0.png"
        ],
        "solution": "+) Với %(n \\leq 10)% đơn giản chỉ cần tính %(\\mathrm{P}=n!)% theo định nghĩa và tìm số %(\\mathrm{k})% lớn nhất để %(\\mathrm{P})% chia hết cho %(m^{k})%. Có thể sử dụng đoạn lệnh:<br>%(\\mathrm{k}=0 \\text {; })%<br>while %(\\mathrm{P})% mod %(\\mathrm{m}=0)% do<br>begin<br>inc(k);<br>P:=P div m;<br>end;<br>+ ) Với %(m)% là số nguyên tố chúng ta nhận xét rằng:<br>- Trong các số %(1,2, \\ldots, n)% có %(\\left[\\frac{n}{m}\\right])% số chia hết cho %(m)%<br>- Trong các số %(1,2, \\ldots ., n)% có %(\\left[\\frac{n}{m^{2}}\\right])% số chia hết cho %(m^{2})%<br>- %(\\ldots)%<br>- Trong các số %(1,2, \\ldots ., n)% có %(\\left[\\frac{n}{m^{p}}\\right])% số chia hết cho %(m^{p})%<br>- %(\\ldots)%<br>Vậy ta co số lượng thừa số %(m)% trong %(n!=1 \\times 2 \\times \\ldots \\times n)% là:<br>%(\\left[\\frac{n}{m}\\right]+\\left[\\frac{n}{m^{2}}\\right]+\\left[\\frac{n}{m^{3}}\\right]+\\cdots)%<br>(Chú ý rằng mặc dù tổng trên có vô hạn số hạng nhưng chỉ có một số hữu hạn các số khác 0)<br>Do đó đáp số bài toán trong trường hợp này là:<br>%(k=\\left[\\frac{n}{m}\\right]+\\left[\\frac{n}{m^{2}}\\right]+\\left[\\frac{n}{m^{3}}\\right]+\\cdots\\ (^*))%<br>+) Trong trường hợp tổng quát. Giả sử %(m)% được phân tích thành tích các thừa số nguyên tố:<br>%(m=x_{1}^{y_{1}} \\times x_{2}^{y_{2}} \\times \\ldots \\times x_{r}^{y_{r}})%<br>(ở đây %(x_{1}, x_{2}, \\ldots, x_{r})% là các số nguyên tố khác nhau)<br>Và giả sử:<br>%(n!=x_{1}^{Z_{1}} \\times x_{2}^{Z_{2}} \\ldots \\times x_{r}^{Z_{r}} \\times Q)%<br>trong đó %(Q)% không chia hết cho %(x_{1}, x_{2}, \\ldots, x_{r})%. Các số %(z_{1}, z_{2}, \\ldots, z_{r})% có thể được tính nhờ sử dụng công thức %((^*))%<br>Khi đó %(n)% ! chia hết cho %(m^{k})% khi và chỉ khi:<br>%(k \\cdot y_{1} \\leq z_{1}, k \\cdot y_{2} \\leq z_{2}, \\ldots ., k \\cdot y_{r} \\leq z_{r})%<br>Do đó giá trị %(k)% lớn nhất là:<br>%(k=\\min \\left\\{\\left[\\frac{z_{1}}{y_{1}}\\right],\\left[\\frac{z_{2}}{y_{2}}\\right], \\ldots,\\left[\\frac{z_{r}}{y_{r}}\\right]\\right\\})%<br>Để phân tích một số thành thừa số nguyên tố chúng ta nhận xét rằng nếu %(a)% là ước nguyên lớn hơn %(1)% của %(x)% thì %(a)% là số nguyên tố. Khi đó với số nguyên %(m)% ta luôn có thể tìm được thừa số nguyên tố nhỏ nhất của %(m)% bằng cách thứ lần lượt %(a=2,3, \\ldots,[\\sqrt{m}])%.<br>Tham khảo chương trình dưới đây:<br><strong>program BAI5;</strong><br><strong>const</strong><br><strong>  tfi='bai5.inp';</strong><br><strong>  tfo='bai5.out';</strong><br><strong>  INF=2000000000;</strong><br><strong>function Lagrange(n, p: longint): longint;</strong><br><strong>var MS:int64;</strong><br><strong>  kq: longint;</strong><br><strong>begin</strong><br><strong>  MS:=p;</strong><br><strong>  kq:=0;</strong><br><strong>  while (MS<=n) do</strong><br><strong>  begin</strong><br><strong>    kq:=kq+n div MS;</strong><br><strong>    MS:=MS*p;</strong><br><strong>  end;</strong><br><strong>  exit(kq);</strong><br><strong>end;</strong><br><strong>procedure main;</strong><br><strong>var n, m : longint;</strong><br><strong>  k: longint;</strong><br><strong>  a, t: longint;</strong><br><strong>  u: longint;</strong><br><strong>begin</strong><br><strong>  assign(input,tfi); reset(input);</strong><br><strong>  assign(output,tfo); rewrite(output);</strong><br><strong>  read(n,m);</strong><br><strong>  k:=INF;</strong><br><strong>  a:=2;</strong><br><strong>  while m>1 do</strong><br><strong>  begin</strong><br><strong>    if a> m div a then</strong><br><strong>    begin</strong><br><strong>      t:=Lagrange(n,m);</strong><br><strong>      if k>t then k:=t;</strong><br><strong>      m:=1;</strong><br><strong>    end else</strong><br><strong>    begin</strong><br><strong>      while (a<=m div a) and (m mod a<>0) do inc(a);</strong><br><strong>      if m mod a=0 then</strong><br><strong>      begin</strong><br><strong>        u:=0;</strong><br><strong>        while m mod a=0 do</strong><br><strong>        begin</strong><br><strong>          inc(u);</strong><br><strong>          m:=m div a;</strong><br><strong>        end;</strong><br><strong>        t:=Lagrange(n,a);</strong><br><strong>        if k>t div u then k:=t div u;</strong><br><strong>      end;</strong><br><strong>    end;</strong><br><strong>  end;</strong><br><strong>  writeln(k);</strong><br><strong>  close(input); close(output);</strong><br><strong>end;</strong><br><strong>BEGIN</strong><br><strong>  main;</strong><br><strong>END.</strong>",
        "question_type": "essay"
    }
]